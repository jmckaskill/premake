
 * Can identify other windows compilers with __CYGWIN32__ and __MINGW32__ (to set windows platform flag)
   See http://predef.sourceforge.net/preos.html for standard defines.

 * Test again with more recent MonoDevelop.
 
 * Generate project files for SharpDevelop 2.0.

 * Reimplement packaging scripts for all projects using Premake. Add a new 'build' 
   action that will launch the toolset to complete the build. So I can do something
   like:

   dobuild("vs2003", "Release")

 * When a package links to a sibling package, the sibling's target is added to the list
   of libraries to link. However, only the target name is added, not the path. This 
   usually works because the targets are all put in the same place. If I link to a lib
   that is kept in the package area (package.target = package.path.."/bin") I don't
   think linking will work.

 * Test that paths in GNU LDDEPS variable are set properly when the package is in a
   subdirectory under the project.

 * Update documentation for resource compiler flags/defines/options.
   If necessary, include remarks of which targets doesn't support which commands.
 
 * Add remarks in documentation for prebuild, postbuild and prelink commands.
 
   Level of target support:
   cb-gcc: prebuild and postbuild
   gnu: prebuild, prelink and postbuild
   vs6: prelink and postbuild
   vs2002~2005: prebuild, prelink and postbuild
   monodev: prebuild and postbuild
   sharpdev: prebuild and postbuild
   
   The monodev and sharpdev targets doesn't support multiple commands, so a workaround 
   can be used (like output a TARGET_postbuild.bat file if more than one command is 
   being used).
   
 * Do testing for prebuild, postbuild and prelink commands.
   
 * Add support for custom build commands.
   Currently only implementable in vs and gnu targets I think.
   
 * Add support for building IDL files on at least the vs targets.
   Not a high priority, but it's a must for COM programming.
   
 * Begin to follow GNU guidelines for the generated makefiles.
   For example, according to them, makefiles should provide install and uninstall rules.
   
 * Add a standard "--prefix" switch to premake.
   
   So the way to compile packages in *nix would be:
   premake --prefix=/usr/local
   make
   make install
   
   And the files specified (by package.install) will be copied to that prefix.
   
 * Make the "gnu" target the default when invoking premake.
   Rationale: Makefile users commonly makes intensive usage of the command line,
   so typing "premake" instead of the longer "premake --target gnu" is easier.
   It can be seen then as a "./configure" replacement (even shorter).
   
   As for other users (ie. Windows IDE users) probably it is more common for 
   them to create a "somefile.bat" which calls "premake --target myide".
   This shields to another point:
   
 * Make a GUI for premake. This is very important for Windows and Mac users who are 
   very GUI-centered and having to type anything can be scaring (or tiresome).
   It can be a bit overkill, but it is necesary. 
   It would be very simple as premake, namely a combobox for chosing the targets,
   a textbox for choosing the "premake.lua", and other controls according to the 
   options given in the premake.lua itself (ie. "--without-tests").
   
 * This also means that the semantic for adding "options" in a premake.lua should
   change, as to diferentiate between: boolean, text, number, path, and file options.

 * A configuration "ini" file can be created for remembering the last target used and so on.
   It can be saved in %APPDATA%\premake.conf in Windows and in ~/premake.conf in the rest.
   
 * For the GUI, I recommend one (or two) of the following GUI toolkits for premake:
 
   * Plain C Win32 GUI for the Windows port.
     Advantages: native, fast, C language, executable very small, almost zero dependency.
     Disvantages: non-portable (only for Windows), a bit more difficult to write than others.
   
   * wxWidgets
     Advantages: cross-platform, native, not slow, C++ language, already included in most *nix and Mac.
     Disvantages: C++ language, executable somewhat bloated in Windows.
   
   * FLTK
     Advantages: cross-platform, fast, C++ language, executable small (but not as small as plain Win32).
     Disvantages: non-native, C++ language.
     
   * Cocoa
     Advantages: native, not slow, dependencies already included in Mac OS X.
     Disvantages: non-portable (only for Mac OS X), Objetive-C, thus only doable by someone who knows.
   
   * GTK
     Advantages: native, dependencies high likely already installed, C language.
     Disvantages: non-native outside *nix, C language, executable rather bloated.
     
   So having this in mind, I can create initially a wxWidgets GUI for all platforms, and then
   if someone can (or I find time) create a plain Win32 alternative, so then Win32 would be used for 
   Windows, and wxWidgets for the rest of platforms. Any other contribution would be also welcomed.
   "First make it work, then make it small".
   
 * Add unsuported platforms. For a way to detect them, see http://predef.sourceforge.net/
   Also, add a "common" platform for all *nix (bsd, linux, solaris, etc) called 
   "unix", "posix" or something like (do it with care, ie. is MacOS a POSIX platform?).
   
 * Get the premake package in official repositories. Get it for at least the most popular ones,
   like Debian (Ubuntu also), Fedora, Suse, BSDs, and MacPorts. 
   The current situation of having to get svn, having to get premake and not having a makefile 
   already generated is not very comfortable either, for new users.
   
 * A big/difficult design change (perhaps for premake 3.5/4.0): 
   Split the compiler and the build system, they are conceptually different.
   Like: premake --compiler=gcc --target=cb
   Ok, this can be done right now in a hackish way, but internally premake doesn't haves 
   conceptually a compiler structure (a Compiler base class as in C++) so the 
   compiler and the build system is very intermingled.
   
 * A list of targets I would like to see support are:
 
   BUILD SYSTEMS:
    - GNU autoconf (Makefile.in files)
    - Code::Blocks (project files)
    - GNU make (makefiles)
    - VC nmake (makefiles)
    - Digital Mars make (makefiles)
    - Digital Mars smake (makefiles)
    - MS eMbedded Visual C++ 4 (project files)
    - Xcode2 (project files)
   
   COMPILERS:
    - GNU GCC (C/C++)
    - GNU GCC Others (ARM, GDC, Fortran, etc)
    - VC (C/C++)
    - Digital Mars (C/C++)
    - Digital Mars (D)
    - Intel (C/C++)
    - Borland (C/C++)
    - OpenWatcom (C/C++)
    - SDCC (C)
    - TinyC (C)

   This would make possible to use for example, Digital Mars C++ inside Code::Blocks (something common)
   or using VC C++ compiler inside GNU make (not as common), or Digital Mars C++ inside 
   GNU make, something not common, but desirable, since the free version of dmars make (not smake)
   is extremelly basic and doesn't even supports conditional logic.

 * Add support for *-config scripts, like wx-config, sdl-config, etc.
   Currently it can be done by inserting back-ticks in the package.buildoptions() manually, but a 
   nicer way would be doing so from premake.
   
   One way can be something like package.buildoptions = { insertshell("wx-config --cflags") }
   
 * Add premake support _specially_ for pkg-config since it's a standard and it works on all platforms.
 
   From the lua side, I'm currently doing this right now:
   (but it would be nice to have it inside premake).
   
   ----------------------------------------------------------------------------------------------------
   -- Links with the specified library using pkg-config
   -- Multiple libraries can be specified separating them by spaces
   function usePkgConfig(package, library)
      if (TARGET == "gnu") then
           -- Inserts for GNU make the $(shell command) function syntax
           tinsert(package.buildoptions, "$(shell pkg-config "..library.." --cflags)")
           tinsert(package.linkoptions,  "$(shell pkg-config "..library.." --libs)")
       elseif (TARGET == "vs6" or TARGET == "vs2002" or TARGET == "vs2003" or TARGET == "vs2005") then
           -- Inserts for MSVC the output of pkg-config directly inside the project
           os.execute("pkg-config "..library.."--cflags --msvc-syntax > respfile_cflags.txt")
           os.execute("pkg-config "..library.."--libs --msvc-syntax > respfile_libs.txt")
           cf = io.open("respfile_cflags.txt")
           li = io.open("respfile_libs.txt")
           tinsert(package.buildoptions, cf:read("*a"))
           tinsert(package.linkoptions, li:read("*a"))
           io.close(cf)
           io.close(li)
           os.remove("respfile_cflags.txt")
           os.remove("respfile_libs.txt")
       else
           -- For all the rest, inserts the backticks `command` syntax
           tinsert(package.buildoptions, "`pkg-config "..library.." --cflags`")
           tinsert(package.linkoptions,  "`pkg-config "..library.." --libs`")
       end
   end
   ----------------------------------------------------------------------------------------------------
   
   It is called like usePkgConfig(package, "freetype") and everything is done automatically, once and 
   for all platforms. That is from lua.
   
   Now from premake, I guess it can be something like:
   package.pkgconfig = { "freetype" }
   or perhaps
   package.links = { findlib("freetype") }
   
 * Add inter-package dependencies, without needing to use package.links()
   An example of usage can be: packageA.depends(packageB)
   
 * There is a bug in GNU when there is a file for example in "../src/main.cpp"
   but you want to compile "../src/testing/main.cpp", GNU make compiles
   "../src/main.cpp" instead.
   
 So the output currently it is:
   
 $(OBJDIR)/main.o: ../src/testing/main.cpp
	-@$(CMD_MKOBJDIR)
	@echo $(notdir $<)
	@$(CXX) $(CXXFLAGS) -o $@ -c $<

and will have to change to this:

 $(OBJDIR)/src/testing/main.o: ../src/testing/main.cpp
	-@$(CMD_MKOBJDIR)
	@echo $(notdir $<)
	@$(CXX) $(CXXFLAGS) -o $@ -c $<

 * There is also a bug when using links("library"),
   it doesn't adds (in some cases?) the relative libpath to it in cb-gcc.
   And for gnu it doesn't adds a libpath but adds the "../lib/path/to/library.a"
   Both seems different bugs.
   
 * In Code::Blocks rev. 3458 project file version has upgraded to 1.6. 
   Differences from 1.5 include changes to accommodate the some new features plus 
   that now only values that differ from the defaults are saved (so project files are smaller now).
   
   Premake has been updated to reflect that, but there are some bugs in Code::Blocks like that if 
   an Unit (a file) doesn't belongs to any target (configuration) it still thinks it belongs to
   all targets, which is the default.
   
   So to make the premake generated project files even more simmilar to what Code::Blocks
   generates as of now, some issues will have to be fixed from Code::Blocks first.
